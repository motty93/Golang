## 基礎go
### ゴルーチン
- 複数の処理を同時に実行する（並行処理）
- `go`キーワードを使用する
- 呼び出し側から見て通常の関数と異なる点は、ゴルーチンとして起動した関数の終了を待たないこと
- 起動したゴルーチンの終了待ちが必要なときや、ゴルーチンの処理結果を受け取るときは`チャネル`を使用する
#### 使用上の注意点
Goのランタイムはデフォルトでスレッドを１つしか利用しないため

```go
package main

import (
  "fmt"
  "os"
)

func main() {
  go func() {
    fmt.Println("Goroutine")
    os.Exit(0)
  }()

  // 無限ループ
  for {
  }
}
```
上記は期待通りの動きをせず、プログラムは終了せず無限ループしてしまうので注意。

解決策としては `GOMAXPROCS`を設定してスレッド数を２異常に設定すれば、期待通りに動作するようになる。

### チャネル
- `chan`で宣言する、初期化されていないチャネルの値は`nil`
- `<-`演算子を使用してチャネルを送信専用・受信専用に制限できる。右側が送信、左側が受信

```go
chan 要素型
chan <- 要素型 // 送信
<- chan 要素型 // 受信
```

### チャネルの作成

```go
make(chan 要素型, キャパシティ)
make(chan 要素型)
```

### チャネルのクローズ
使用しなくなったチャネルは`close`組み込み関数を使用してクローズする。ただし、受信専用チャネルはクローズできないので注意。また、クローズ済みのチャネルに値を送信することは出来ず、送信しようとするとpanicが発生する。

### セマフォの代用
チャネルはセマフォの代わりとしても使用でき、同時に実行できるゴルーチン数の制限が出来る。

`セマフォ`：並行処理において、リソースへの同時アクセスを抑制する仕組みのこと

`semaphore.go`を参照

### 値の共用
ゴルーチン間で値を共用するときもチャネルを使用するのが一般的。

共用変数の代わりとなる値をチャネルで引き回すことによって、複数のゴルーチンによる値の同時アクセスを防ぐことが出来る。

### 一定時間ごとに処理を行う
timeパッケージのTick関数で作成したチェネルから受信する

`tick.go`を参照

## 簡素webサーバー
- `net/http`を使用
- `http.ListenAndServe`でポート指定のサーバーを立ち上げる
- `http.HandleFunc`を使ってルーティング・ハンドラーの設定を行う
- ハンドラーには第一引数に`http.ResponseWriter`第二引数に`*http.Request`を渡す
- `*http.Request`ではrequest bodyやquery parameterを取得できる
